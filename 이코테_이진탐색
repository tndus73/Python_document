# 이진탐색
- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터 탐색
- 시작점, 끝점, 중간점 인덱스 이용
- 파라메트릭 서치(최적화 문제를 결정문제(yes,no)로 바꾸어 해결하는 기법)일 때 사
- 시간 복잡도 O(logN)

ex) 재귀적 구현
def binary_search(array, target, start, end):
  if start > end:
      return Noe
  mid = (start + end) // 2
  if array[mid] == target:
      return mid
  elif array[mid] > target:  #중간점 값보다 찾고 싶은 값이 작은 경우 왼쪽 확인
      return binary_search(array, target, start, mid - 1)
  else:  #중간점 값보다 찾고 싶은 값이 큰 경우 오른쪽 확인
      return binary_search(array, target, mid + 1, end)
# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, tartget = list(map(int, input().split()))
# 전체 원소 입력 받기
array = list(map(int, input().split()))
#이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n-1)
if result == None:
    print("원소가 존재하지 않습니다")
else:
    print(result + 1)

ex) 간단한 방법 : 이진 탐색 라이브러리
bisect_left(a, x) : 정렬된 순서 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스 반환
bisect_right(a, x) : 정렬된 순서 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스 반환

from bisect import bisect_left, bisect_right
def count_by_range(a, left_value, right_value):  #값이 left_value, right_value인 데이터 개수를 반환하는 함수
    right_index = bisect_right(a, right_value)
    left_index = bisect_left(a, left_value)
    return right_index - left_index
a = [1,2,3,3,3,3,4,4,8,9]  #배열 선언
print(count_by_range(a, 4, 4))  #값이 4인 데이터 개수 출력
print(count_by_range(a, -1, 3))  #값이 [-1, 3] 범위에 있는 데이터 개수 출력

예시) 요청한  길이가 M일대 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 높이 최대값
풀이)
# 떡의 개수(N)과 요청한 떡의 길이(M)을 입력
n, m = list(map(int, input().split(' ')))
# 각 떡의 개별 높이 정보 입력
array = list(map(int, input().split()))
# 이진 탐색 시작점과 끝점 설정
start = 0
end = max(array)
# 이진 탐색 수행 (반복)
result = 0
while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in array:
        if x > mid:  #잘랐을 때 떡의 양
            total += x - mid
    #떡의 양이 부족한 경우 더 많이 자르기(왼쪽 부분 탐색)
    if total < m :
        end = mid - 1
    #떡의 양이 부족한 경우 더 많이 자르기(오른쪽 부분 탐색)
    else:
        result = mid  #최대한 덜 잘랐을 때가 정답이므로, 여기서 result에 기록
        start = mid + 1
print(result)

예시) 정렬된 배열에서 특정 수(x)의 개수 구하기
1. 첫번째 줄에 N과 x가 정수 형태로 공백으로 구분되어 입력
2. 둘째 줄에 N의 원소가 정수 형태로 공배긍로 구분되어 입력
풀이)
from bisect import bisect_left, bisect_right

def count_by_range(array, left_value, right_value):
    right_index = bisect_right(array, right_value)
    left_index = bisect_left(array, left_value)
    return right_index - left_index

n, x = map(int, input().split())  #데이터 개수 N, 찾고자 하는 값 x 입력받기
array = list(map(int, input().split()))
count = count_by_range(array, x, x)
# 값이 x인 원소가 없으면
if count == 0:
    print(-1)
else: # 값이 x인 원소가 있으
    print(count)
