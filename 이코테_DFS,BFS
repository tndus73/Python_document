# DFS (그래프 탐색 알고리즘 : 깊이 우선 탐색)
  - 그래프 모양은 2차원 리스트
  - 스택(선입후출) 자료 구조 이용 → 리스트 이용
ex)
# DFS 메서드 정의  
def dfs(graph, v, visited):
      visited[v] = True  #현재노드 방문처리
      print(v, end='')
      for i in graph[i]:  #현재 노드와 연결된 다른 노드를 재귀적으로 방문
          if not visited[i]:
              dfs(graph, i, visited)
# 각 노드가 연결된 정보 표현 (2차원 리스트)        
graph = [
        [],  #노드번호가 대부분 1부터 시작하기 때문에 0번 인덱스는 비워둠
        [2,3,8],  #1번 인덱스와 인접한 노드
        [1,7]  #2번 인덱스와 인접한 노드
        ...  #마지막 인덱스와 인접한 노드
  ]
visited = [False] * 9  #각 노드가 방문한 정보를 1차원 리스트 자료형으로 표현
dfs(graph, 1, visited)

# 재귀함수 (반복문을 이용해 동일한 기능 구현 가능)
- 자기 자신을 다시 호출하는 함수
- 종료 조건 반드시 명시해야함

# BFS (그래프 탐색 알고리즘 : 너비 우선 탐색)
  - 그래프 모양은 2차원 리스트
  - 큐(선입선출) 자료 구조 이용 → deque 이용
  - 리스트 사용하면 시간복잡도 높아짐
ex)
from collections import deque
# BFS 메서드 정의
def bts(graph, start, visited):
    queue = deque([start])  #큐 구현하기 위해 deque라이브러리 사용
    visited[start] = True  #현재 노드 방문 처리
    while queue:  #큐가 빌때까지 반복
          v = queue.popleft()  #큐에서 원소 하나씩 뽑아 출력
          print(v, end='')
          for i in graph[v]:  #아직 방문하지 않은 인접한 원소들 큐에 삽입
              if not visited[i]:
                 queue.append(i)
                 visited[i] = True
# 각 노드가 연결된 정보 표현 (2차원 리스트)        
graph = [
        [],  #노드번호가 대부분 1부터 시작하기 때문에 0번 인덱스는 비워둠
        [2,3,8],  #1번 인덱스와 인접한 노드
        [1,7]  #2번 인덱스와 인접한 노드
        ...  #마지막 인덱스와 인접한 노드
  ]
visited = [False] * 9  #각 노드가 방문한 정보를 1차원 리스트 자료형으로 표현
bfs(graph, 1, visited)    
