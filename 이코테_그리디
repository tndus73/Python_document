# 그리디 알고리즘(탐욕법)
- 현재 상황에서 가장 좋은 것만 고르는 방법
- 최적의 해를 구할 수 있는지 검토(코테에서는 그리디 알고리즘으로 얻은 해가 최적의 해인 경우가 많음)

예시) 거스름 돈 최소 개수
- 가장 큰 화폐부터 거슬러 주는 것이 최적의 해
- 시간복잡도 O(K) : 화폐종류 k개의 영향

풀이)
n = 1260
count = 0
array = [500, 100, 50, 10]
for coin in array:
  count += n // coin
  n %= coin  #coin으로 나눈 나머지값 n에 삽입
print(count)

예시) 1이 될 때까지 최소 개수
1. N에서 1을 뺍니다.(나누어 떨어지지 않을 때)
2. N을 K로 나눕니다.
- 최대한 많이 나누기

풀이1)
n, k = map(int, input().split())
result = 0
#N이 K이상이라면 K로 계속 나누기
while n >= k:
  while n % k != 0:  #N이 K로 나누어 떨어지지 않는다면 N에서 1빼기
        n -= 1
        result += 1
  n //= k  #나누어 떨어진다면 k로 나눈 몫 n에 삽입
  result +=1
#마지막으로 남은 수에 대하여 1씩 빼기
while n > 1 :
  n -= 1
  result += 1
print(result)

풀이2) 시간복잡도 log(K)로 단축
n, k = map(int, input().split())
result = 0
while True:
  target = (n // k) * K  #K로 나누어 떨어지지 않을때 가장 가까운 K로 나누어 떨어지는 값
  result += (n - target)  #1을 빼는 연산 횟수 한번에 계산
  n = target
  if n < k:
      break
  result += 1  #N이 K보다 크면 횟수 추가하고
  n //= k  #k로 나눈 몫 n에 삽입
#마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)

예시) 곱하기 혹은 더해서 가장 큰 수 (사칙연산X, 순서대로 계산)
- 두 수 연산 수행할 때, 하나라도 1이하인 경우 더하고, 모두 2이상인 경우 곱한다.

풀이)
data  = input()
result = int(data[0])  #첫번째 문자를 숫자로 변경
for i in range(1, len(data)):
  num = int(data[i])
  if num <=1 or result <= 1:
      result += num
  else:
      result *= num
print(result)

예시) 모험가 길드 그룹 최대
1. 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여
- 오름차순 정렬 후 '현재 그룹에 포함된 모험가 수' >= '현재 공포도'

풀이)
n = int(input())
data = list(map(int, input().split())
data.sort()
group = 0  #총 그룹 수
member = 0  #현재 그룹에 포함된 모험가 수
for i in data:
  member += 1
  if member >= i : #현재 그룹에 포함된 모험가 수가 현재 공포도 이상이라면, 그룹
      group += 1
      member = 0
print(group)
