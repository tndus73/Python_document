# 그리디 알고리즘(탐욕법)
- 현재 상황에서 가장 좋은 것만 고르는 방법
- 최적의 해를 구할 수 있는지 검토(코테에서는 그리디 알고리즘으로 얻은 해가 최적의 해인 경우가 많음)

예시) 거스름 돈 최소 개수
- 가장 큰 화폐부터 거슬러 주는 것이 최적의 해
- 시간복잡도 O(K) : 화폐종류 k개의 영향
풀이)
n = 1260
count = 0
array = [500, 100, 50, 10]
for coin in array:
  count += n // coin
  n %= coin  #coin으로 나눈 나머지값 n에 삽입
print(count)

예시) 1이 될 때까지 최소 개수
1. N에서 1을 뺍니다.(나누어 떨어지지 않을 때)
2. N을 K로 나눕니다.
- 최대한 많이 나누기
풀이1)
n, k = map(int, input().split())
result = 0
#N이 K이상이라면 K로 계속 나누기
while n >= k:
  while n % k != 0:  #N이 K로 나누어 떨어지지 않는다면 N에서 1빼기
        n -= 1
        result += 1
  n //= k  #나누어 떨어진다면 k로 나눈 몫 n에 삽입
  result +=1
#마지막으로 남은 수에 대하여 1씩 빼기
while n > 1 :
  n -= 1
  result += 1
print(result)

풀이2) 시간복잡도 log(K)로 단축
n, k = map(int, input().split())
result = 0
while True:
  target = (n // k) * K  #K로 나누어 떨어지지 않을때 가장 가까운 K로 나누어 떨어지는 값
  result += (n - target)  #1을 빼는 연산 횟수 한번에 계산
  n = target
  if n < k:
      break
  result += 1  #N이 K보다 크면 횟수 추가하고
  n //= k  #k로 나눈 몫 n에 삽입
#마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)

