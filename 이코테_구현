# 구현
- 풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제
ex)
- 알고리즘은 간단한데 코드가 길어지는 문제
- 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
- 문자열을 특정 기준에 따라 끊어 처리해야 하는 문제
- 적절한 라이브러리 찾아서 사용해야 하는 문제(순열, 조합...)

예시) 상하좌우
1. 시작 좌표 (1,1)
2. L(왼), R(오), U(위), D(아래)
3. 정사각형 공간 벗어나는 움직임은 무시
- 시뮬레이션 유형(개체를 차례로 이동), 구현 유형, 완전 탐색 유형은 서로 유사

풀이)
n = int(input)
x, y = 1, 1
plans = input().split()

dx = [0,0,-1,1]  #x 변화량 (열 이동 : 상하)
dy = [-1,1,0,0]  #y 변화량 (행 이동 : 좌우)
move_types = ['L','R','U','D']

for plan in plans:  #이동 계획 확인
  for i in range(len(move_types)):
      if plan == move_types[i]:
          nx = x + dx[i]
          ny = y + dy[i]
  if nx < 1 or ny < 1 or nx > n or ny > n:  #공간을 벗어나는 경우 무시
      continue
  x, y = nx, ny
print(x,y)

예시) 시각(00시00분00초부터 N시(0<=N<=23)59분59초까지) 중 N이 하나라도 포함되는 경우
- 가능한 모든 시각의 경우를 하나씩 모두 세어 푸는 문제(완전 탐색)

풀이)
n = int(input())
count = 0
for i in range(n+1):  #시
  for j in range(60):  #분
    for k in rnage(60):  #초
          if '3' in str(i)+str(j)+str(k):
              count += 1
print(count)

예시) 왕실의 나이트(L자 형태로 이동 가능한 말)가 갈 수 있는 수
1. 수평으로 두 칸 이동한 뒤 수직으로 한 칸 이동
2. 수직으로 두 칸 이동한 뒤 수평으로 한 칸 이동
- 행 위치를 1~8로 표현, 열 위치를 a~h로 표현
ex) a1 -> 2

풀이)
input_data = input()  #현재 나이트 위치 입력
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1

#나이트가 이동 할 수 있는 8가지 방향 정의(위 문제 dx, dy 기능)
steps = [(-2,-1), (-2,1), (-1,-2), (-1,2), (1,-2), (1,2), (2,-1), (2,1)]

#8가지 방향에 대해 각 위치로 이동이 가능한지
result = 0
for step in steps:
  #이동하고 싶은 위치 확인
  next_row = row + step[0]
  next_column = column + step[1]
  #해당 위치로 이동 가능하면 카운트 증가
  if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
      result += 1
print(result)

예시) 문자열 재정렬(알파벳 오름차순 + 모든 숫자 더한 값)
- 숫자인 경우 따로 합계 계싼
- 알파벳의 경우 별도의 리스트에 저장 후 정렬

풀이)
data = input()
alphabet = []
num = 0
#문자 확인하여 알파벳 숫자 구분
for x in data:
  if x.isalpha():
      alphabet.append(x)
  else:
      num += int(x)
#알파벳 오름차순 정렬
alphabet.sort()
#숫자 있는 경우 가장 뒤에 삽입
if num != 0:
    alphabet.append(str(num))
print(''.join(alphabet))  #리스트가 전체 문자열일때, '구분자'.join(리스트)하면 구분자로 구분하여 출력
